\hypertarget{notes_8txt}{}\section{notes.\+txt File Reference}
\label{notes_8txt}\index{notes.\+txt@{notes.\+txt}}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial \hyperlink{notes_8txt_abd9a65452f6ea6a1b99ec30c8a0ef8e4}{state}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry \hyperlink{notes_8txt_af94996a6cb9ce95900afa88455dbe21f}{Initially}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case \hyperlink{notes_8txt_a6b7da13421790a7ae65cd85c74905636}{scenario}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single page We will find the \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to split How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free chunk of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum order we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free \hyperlink{notes_8txt_a714a30bc4feaa1e3997f8a58f898130c}{lists}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a8179423c2498b704bb92e1a1f67cfa3d}{place}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} not clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or not The name suggests \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work \hyperlink{notes_8txt_a44e446e457f5bbf4681104b47dacf206}{First}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current so we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} so we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a8c31bb9cef90c63b642e6d5cc012829d}{available}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} will always be at the current level Chunks will be \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} be \hyperlink{notes_8txt_a6ad1a4d083c4930bd2c2e57e3eb0f8e1}{contiguous}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that it \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} it will always be at the current level Chunks will be \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} be but \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} within chunks will Thus we need to identify the index of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} within our buddy s and scan through the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} for that index When we find \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} will always be at the current level Chunks will be \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} be but \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} within chunks will Thus we need to identify the index of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} within our buddy s and scan through the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} for that index When we find we need one more \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} pointer to get the end of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} This will allow us to set its next to the head of the second and the previous of the second \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} s head to the tail of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} After the joining \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a567dce96449c045c4c1d67230c092e31}{complete}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} will always be at the current level Chunks will be \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} be but \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} within chunks will Thus we need to identify the index of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} within our buddy s and scan through the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} for that index When we find we need one more \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} pointer to get the end of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} This will allow us to set its next to the head of the second and the previous of the second \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} s head to the tail of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} After the joining \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} should be added \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} to the next size up of memory pool When \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} are \hyperlink{notes_8txt_a8f7e96f64f2d4d0e9eb1dc711bf5ba3d}{allocated}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} list Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest list with a free entry this will be only the list Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest list with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest list We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the list The instructions say to always take the head of the list when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching list \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the list If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} will always be at the current level Chunks will be \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} be but \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} within chunks will Thus we need to identify the index of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} within our buddy s and scan through the list for that index When we find we need one more list pointer to get the end of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} This will allow us to set its next to the head of the second and the previous of the second \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} s head to the tail of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} After the joining \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} should be added \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} to the next size up of memory pool When \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} are they should be tracked \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} a separate \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} will always be at the current level Chunks will be \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} be but \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} within chunks will Thus we need to identify the index of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} within our buddy s and scan through the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} for that index When we find we need one more \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} pointer to get the end of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} This will allow us to set its next to the head of the second and the previous of the second \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} s head to the tail of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} After the joining \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} should be added \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} to the next size up of memory pool When \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} are they should be tracked \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} a separate to be reinstated on free This maintains that only free chunks exist \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} arrays One idea \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} just to track the starting address and the \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} a separate \hyperlink{notes_8txt_aeb8c646dbe282a58600b038dd7f0fed2}{struct}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} as written and add that half of \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} will always be at the current level Chunks will be \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} be but \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} within chunks will Thus we need to identify the index of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} within our buddy s and scan through the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} for that index When we find we need one more \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} pointer to get the end of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} This will allow us to set its next to the head of the second and the previous of the second \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} s head to the tail of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} After the joining \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} should be added \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} to the next size up of memory pool When \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages} are they should be tracked \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} a separate to be reinstated on free This maintains that only free chunks exist \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} arrays One idea \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} just to track the starting address and the \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} a separate the bare minimum required for bookkeeping \hyperlink{notes_8txt_aa77f78242f5beeaae0c73ac608521b08}{Then}
\item 
Initialize the buddy system We begin with the entirety of memory \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the largest \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Since our minimum \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} we allocate at least every time This \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the initial we find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free entry this will be only the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} Say we have a worst case we need only a single \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} We will find the and need to decide if we need to \hyperlink{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{split} How will splitting work need to find the smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} with a free \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} of pages if that \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} can be we need to load all the pages into the next smallest \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} We know the size of the current \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we can determine the number of pages to push Pages must be pushed \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} since we need to maintain \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} within chunks It might also be wise to mark the pages as written and add that half of pages to the back of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} The instructions say to always take the head of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} when checking the free which ties into why this method \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} fast enough \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{so} we shouldn t violate that Something to consider \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} that \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} clear whether the used pages belong \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} or \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} The name suggests but the comments seem to contradict this The \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} step when allocating a block \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} checking IF the head of the matching \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} to free While doing retain the pointer to the final member of the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} If our buddy \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} \hyperlink{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{it} will always be at the current level Chunks will be \hyperlink{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{not} be but pages within chunks will Thus we need to identify the index of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{page} within our buddy s and scan through the \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} for that index When we find we need one more \hyperlink{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{list} pointer to get the end of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} This will allow us to set its next to the head of the second and the previous of the second \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} s head to the tail of the \hyperlink{notes_8txt_accf77c448218df9fd25c4423d2869fba}{first} \hyperlink{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{chunk} After the joining \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} the pages should be added \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} to the next size up of memory pool When pages are they should be tracked \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} a separate to be reinstated on free This maintains that only free chunks exist \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} the \hyperlink{buddy_8c_a6d390a89d1f6c149cef6284d2c0351df}{free\+\_\+area} arrays One idea \hyperlink{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{is} just to track the starting address and the \hyperlink{notes_8txt_ae170b788b9ce36849b8a92724a029135}{order} \hyperlink{simulator_8c_aca392a8d3941cd0740aef3ad92545d67}{in} a separate the bare minimum required for bookkeeping when returning \hyperlink{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{pages}
\end{DoxyCompactItemize}


\subsection{Variable Documentation}
\index{notes.\+txt@{notes.\+txt}!allocated@{allocated}}
\index{allocated@{allocated}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{allocated}{allocated}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be but {\bf pages} within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the {\bf list} for that index When we find we need one more {\bf list} pointer to get the end of the {\bf first} {\bf chunk} This will allow us to set its next to the head of the second and the previous of the second {\bf chunk} s head to the tail of the {\bf first} {\bf chunk} After the joining {\bf is} the {\bf pages} should be added {\bf in} {\bf order} to the next size up of memory pool When {\bf pages} are allocated}\hypertarget{notes_8txt_a8f7e96f64f2d4d0e9eb1dc711bf5ba3d}{}\label{notes_8txt_a8f7e96f64f2d4d0e9eb1dc711bf5ba3d}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!available@{available}}
\index{available@{available}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{available}{available}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} available}\hypertarget{notes_8txt_a8c31bb9cef90c63b642e6d5cc012829d}{}\label{notes_8txt_a8c31bb9cef90c63b642e6d5cc012829d}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!chunk@{chunk}}
\index{chunk@{chunk}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{chunk}{chunk}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free chunk of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be but {\bf pages} within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the {\bf list} for that index When we find we need one more {\bf list} pointer to get the end of the {\bf first} chunk This will allow us to set its next to the head of the second chunk}\hypertarget{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}{}\label{notes_8txt_a60c3f3ea1420be8254648913cbf8b336}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!complete@{complete}}
\index{complete@{complete}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{complete}{complete}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be but {\bf pages} within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the {\bf list} for that index When we find we need one more {\bf list} pointer to get the end of the {\bf first} {\bf chunk} This will allow us to set its next to the head of the second and the previous of the second {\bf chunk} s head to the tail of the {\bf first} {\bf chunk} After the joining {\bf is} complete}\hypertarget{notes_8txt_a567dce96449c045c4c1d67230c092e31}{}\label{notes_8txt_a567dce96449c045c4c1d67230c092e31}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!contiguous@{contiguous}}
\index{contiguous@{contiguous}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{contiguous}{contiguous}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be contiguous}\hypertarget{notes_8txt_a6ad1a4d083c4930bd2c2e57e3eb0f8e1}{}\label{notes_8txt_a6ad1a4d083c4930bd2c2e57e3eb0f8e1}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!first@{first}}
\index{first@{first}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{first}{first}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written first}\hypertarget{notes_8txt_accf77c448218df9fd25c4423d2869fba}{}\label{notes_8txt_accf77c448218df9fd25c4423d2869fba}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!First@{First}}
\index{First@{First}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{First}{First}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work First}\hypertarget{notes_8txt_a44e446e457f5bbf4681104b47dacf206}{}\label{notes_8txt_a44e446e457f5bbf4681104b47dacf206}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!Initially@{Initially}}
\index{Initially@{Initially}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{Initially}{Initially}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry Initially}\hypertarget{notes_8txt_af94996a6cb9ce95900afa88455dbe21f}{}\label{notes_8txt_af94996a6cb9ce95900afa88455dbe21f}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!is@{is}}
\index{is@{is}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{is}{is}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} is}\hypertarget{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}{}\label{notes_8txt_afdcba1605c13ab6a6a89a58079be00f2}


Definition at line 5 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!it@{it}}
\index{it@{it}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{it}{it}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that it {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} it will always be at the current level Chunks will be {\bf not} be but {\bf pages} within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the {\bf list} for that index When we find it}\hypertarget{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}{}\label{notes_8txt_a4ce567c95a3c0db618dea1cb3c81173b}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!list@{list}}
\index{list@{list}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{list}{list}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} list Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest list with a free entry this will be only the list Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest list with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest list We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the list The instructions say to always take the head of the list when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching list {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the list If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be but {\bf pages} within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the list for that index When we find we need one more list pointer to get the end of the {\bf first} {\bf chunk} This will allow us to set its next to the head of the second and the previous of the second {\bf chunk} s head to the tail of the {\bf first} {\bf chunk} After the joining {\bf is} the {\bf pages} should be added {\bf in} {\bf order} to the next size up of memory pool When {\bf pages} are they should be tracked {\bf in} a separate list}\hypertarget{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}{}\label{notes_8txt_a4ee6db26bad3dd738a9a0384595fe358}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!lists@{lists}}
\index{lists@{lists}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{lists}{lists}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free lists}\hypertarget{notes_8txt_a714a30bc4feaa1e3997f8a58f898130c}{}\label{notes_8txt_a714a30bc4feaa1e3997f8a58f898130c}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!not@{not}}
\index{not@{not}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{not}{not}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} not clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or not The name suggests not}\hypertarget{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}{}\label{notes_8txt_ac0c86bc9d520a3d319a4c5083848fab9}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!order@{order}}
\index{order@{order}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{order}{order}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum order we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain order within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be but {\bf pages} within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the {\bf list} for that index When we find we need one more {\bf list} pointer to get the end of the {\bf first} {\bf chunk} This will allow us to set its next to the head of the second and the previous of the second {\bf chunk} s head to the tail of the {\bf first} {\bf chunk} After the joining {\bf is} the {\bf pages} should be added {\bf in} order to the next size up of memory pool When {\bf pages} are they should be tracked {\bf in} a separate to be reinstated on free This maintains that only free chunks exist {\bf in} the {\bf free\+\_\+area} arrays One idea {\bf is} just to track the starting address and the order {\bf in} a separate the bare minimum required for bookkeeping when returning generate a {\bf page} for each one {\bf in} order}\hypertarget{notes_8txt_ae170b788b9ce36849b8a92724a029135}{}\label{notes_8txt_ae170b788b9ce36849b8a92724a029135}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!page@{page}}
\index{page@{page}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{page}{page}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single page We will find the page}\hypertarget{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}{}\label{notes_8txt_af75b9551a58e7c4fa475d037e21d2e46}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!pages@{pages}}
\index{pages@{pages}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{pages}{pages}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of pages if that {\bf page} can be we need to load all the pages into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of pages to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the pages as written and add that half of pages to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used pages belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be but pages within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the {\bf list} for that index When we find we need one more {\bf list} pointer to get the end of the {\bf first} {\bf chunk} This will allow us to set its next to the head of the second and the previous of the second {\bf chunk} s head to the tail of the {\bf first} {\bf chunk} After the joining {\bf is} the pages should be added {\bf in} {\bf order} to the next size up of memory pool When pages are they should be tracked {\bf in} a separate to be reinstated on free This maintains that only free chunks exist {\bf in} the {\bf free\+\_\+area} arrays One idea {\bf is} just to track the starting address and the {\bf order} {\bf in} a separate the bare minimum required for bookkeeping when returning pages}\hypertarget{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}{}\label{notes_8txt_a591847dfa4e8c250a8c08a63e5063001}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!place@{place}}
\index{place@{place}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{place}{place}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} place}\hypertarget{notes_8txt_a8179423c2498b704bb92e1a1f67cfa3d}{}\label{notes_8txt_a8179423c2498b704bb92e1a1f67cfa3d}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!scenario@{scenario}}
\index{scenario@{scenario}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{scenario}{scenario}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case scenario}\hypertarget{notes_8txt_a6b7da13421790a7ae65cd85c74905636}{}\label{notes_8txt_a6b7da13421790a7ae65cd85c74905636}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!so@{so}}
\index{so@{so}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{so}{so}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current so we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} so we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing so}\hypertarget{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}{}\label{notes_8txt_a94bb352e5752d8ad57a98d778a6ac2e5}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!split@{split}}
\index{split@{split}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{split}{split}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to split How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be split}\hypertarget{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}{}\label{notes_8txt_a4b5d94b2e51a5d61abee5e3d1156f235}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!state@{state}}
\index{state@{state}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{state}{state}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial state}\hypertarget{notes_8txt_abd9a65452f6ea6a1b99ec30c8a0ef8e4}{}\label{notes_8txt_abd9a65452f6ea6a1b99ec30c8a0ef8e4}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{[]\}
128k    \{\}
64k     \{\}
32k  \{\}
16k  \{\}
8k      \{\}
4k      \{\}

On add
\end{DoxyCode}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!struct@{struct}}
\index{struct@{struct}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{struct}{struct}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be but {\bf pages} within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the {\bf list} for that index When we find we need one more {\bf list} pointer to get the end of the {\bf first} {\bf chunk} This will allow us to set its next to the head of the second and the previous of the second {\bf chunk} s head to the tail of the {\bf first} {\bf chunk} After the joining {\bf is} the {\bf pages} should be added {\bf in} {\bf order} to the next size up of memory pool When {\bf pages} are they should be tracked {\bf in} a separate to be reinstated on free This maintains that only free chunks exist {\bf in} the {\bf free\+\_\+area} arrays One idea {\bf is} just to track the starting address and the {\bf order} {\bf in} a separate struct}\hypertarget{notes_8txt_aeb8c646dbe282a58600b038dd7f0fed2}{}\label{notes_8txt_aeb8c646dbe282a58600b038dd7f0fed2}


Definition at line 8 of file notes.\+txt.

\index{notes.\+txt@{notes.\+txt}!Then@{Then}}
\index{Then@{Then}!notes.\+txt@{notes.\+txt}}
\subsubsection[{\texorpdfstring{Then}{Then}}]{\setlength{\rightskip}{0pt plus 5cm}Initialize the buddy system We begin with the entirety of memory {\bf in} the largest {\bf free\+\_\+area} {\bf list} Since our minimum {\bf order} we allocate at least every time This {\bf is} the initial we find the smallest {\bf list} with a free entry this will be only the {\bf list} Say we have a worst case we need only a single {\bf page} We will find the and need to decide if we need to {\bf split} How will splitting work need to find the smallest {\bf list} with a free {\bf chunk} of {\bf pages} if that {\bf page} can be we need to load all the {\bf pages} into the next smallest {\bf list} We know the size of the current {\bf so} we can determine the number of {\bf pages} to push Pages must be pushed {\bf in} since we need to maintain {\bf order} within chunks It might also be wise to mark the {\bf pages} as written and add that half of {\bf pages} to the back of the {\bf list} The instructions say to always take the head of the {\bf list} when checking the free which ties into why this method {\bf is} fast enough {\bf in} the {\bf first} {\bf so} we shouldn t violate that Something to consider {\bf is} that {\bf it} {\bf is} {\bf not} clear whether the used {\bf pages} belong {\bf in} the {\bf free\+\_\+area} or {\bf not} The name suggests but the comments seem to contradict this The {\bf first} step when allocating a block {\bf is} checking IF the head of the matching {\bf list} {\bf is} free This indicates that the F\+R\+E\+E\+\_\+\+A\+R\+EA contains N\+O\+N\+F\+R\+EE chunks W\+TF How will joining work set each {\bf page} to free While doing retain the pointer to the final member of the {\bf list} If our buddy {\bf is} {\bf it} will always be at the current level Chunks will be {\bf not} be but {\bf pages} within chunks will Thus we need to identify the index of the {\bf first} {\bf page} within our buddy s and scan through the {\bf list} for that index When we find we need one more {\bf list} pointer to get the end of the {\bf first} {\bf chunk} This will allow us to set its next to the head of the second and the previous of the second {\bf chunk} s head to the tail of the {\bf first} {\bf chunk} After the joining {\bf is} the {\bf pages} should be added {\bf in} {\bf order} to the next size up of memory pool When {\bf pages} are they should be tracked {\bf in} a separate to be reinstated on free This maintains that only free chunks exist {\bf in} the {\bf free\+\_\+area} arrays One idea {\bf is} just to track the starting address and the {\bf order} {\bf in} a separate the bare minimum required for bookkeeping Then}\hypertarget{notes_8txt_aa77f78242f5beeaae0c73ac608521b08}{}\label{notes_8txt_aa77f78242f5beeaae0c73ac608521b08}


Definition at line 8 of file notes.\+txt.

